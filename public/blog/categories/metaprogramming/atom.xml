<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: metaprogramming | Yet Another Kinopyo Blog]]></title>
  <link href="http://kinopyo.github.com/blog/categories/metaprogramming/atom.xml" rel="self"/>
  <link href="http://kinopyo.github.com/"/>
  <updated>2012-08-26T12:20:36+09:00</updated>
  <id>http://kinopyo.github.com/</id>
  <author>
    <name><![CDATA[Qihuan Piao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby instance_eval()の解説、Rails ActiveRecordとActiveSupportでの応用例]]></title>
    <link href="http://kinopyo.github.com/blog/ruby-instance_eval-and-how-used-in-rails-active-record-and-active-support"/>
    <updated>2011-09-12T00:00:00+09:00</updated>
    <id>http://kinopyo.github.com/blog/ruby-instance_eval-and-how-used-in-rails-active-record-and-active-support</id>
    <content type="html"><![CDATA[<p>下記ソースコードに英語コメントで書いてますが、日本語で解釈してみます。</p>

<p><em>gist id=d5eef13c647570612621 file=instance_eval.rb</em></p>

<h2>定義</h2>

<p>まずinstance_evalはObjectのインスタンスメソッドです。なので全てのオブジェクトがこのinstance_evalを呼び出すことができます。instance_evalはブロックを受け取ります。</p>

<h2>機能</h2>

<ul>
<li>呼び出すオブジェクト(receiver)のスコープ内でブロックを評価(実行)する、つまりreceiverのプライベートメソッドやインスタンス変数にアクセスできること</li>
<li>現在スコープの変数などBindingにアクセスできる</li>
</ul>


<p>サンプルコードではPersonというclassに@nameのインスタンス変数、credit_cardというプライベートメソッドを定義しました。
someoneはPersonのインスタンスで、someoneからinstance_evalをコールすると、そのブロック内ではselfがsomeoneとなり、@nameやcredit_cardにアクセスできます。
さらにinstance_evalの外で定義した変数outter_valにもアクセスできます。</p>

<h2>Real-life example</h2>

<p>さて、原理は分かったとして、実際はどのように使われているのか、Railsのソースコードでgrepしてこんなコードが見つかりました。</p>

<h3>in ActiveRecord</h3>

<p>まずマイグレーションでまあよく使うchange_columnメソッドのソースコードです。
<em>gist id=d5eef13c647570612621 file=instance_eval_in_rails_active_record.rb</em></p>

<p><strong>definition<em>column_name]</strong>がinstance_evalを呼び出したのですが、definition[column_name</em>はActiveRecord::ConnectionAdapters::ColumnDefinitionクラスのオブジェクトで、ColumnDefinitionの実態はStructを継承し、カラムの名前、種類、limit、precision、デフォルト値などの情報が格納されているオブジェクトです。
<em>gist id=d5eef13c647570612621 file=column_definition.rb</em></p>

<p>definition<em>column_name</em>.instance_evalを使うことで、そのオブジェクト(テーブルカラム)の種類、limit、default値とnull可否を変更することが分かりましたね。
optionsはinstance_evalブロックの外の変数ですが、普通にアクセスできます。</p>

<h3>in ActiveSupport</h3>

<p><em>gist id=d5eef13c647570612621 file=instance_eval_in_rails_active_support.rb</em>
上記ActiveRecordのコードが分かればここは分かりやすいと思います。
実際の意味はさておき、instance_evalを利用して@marshal_with_utc_coercionというインスタンス変数が定義されていれば、それを削除する使い方ですね。</p>

<h3>まとめ</h3>

<p>instance_evalを使ってオブジェクトの構造(インスタンス変数の値の変更、インスタンス変数の追加削除など)を実行時に変更するのが使い道、というのが個人的な感想です。</p>

<p>最後に注記：この記事はRails3.1.0のソースコードを使ってます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby: 既存クラスにメソッドを追加、class_evalとsingleton method]]></title>
    <link href="http://kinopyo.github.com/blog/ruby-add-method-to-string-class"/>
    <updated>2011-09-09T00:00:00+09:00</updated>
    <id>http://kinopyo.github.com/blog/ruby-add-method-to-string-class</id>
    <content type="html"><![CDATA[<p>Rubyのクラスにメソッドを追加する方法です。ここではStringを例にしました。</p>

<p><em>gist id=1205255 file=solution_1.rb</em>
solution_1.rbはOpen Classというテクニックです。classキーワードで既存クラスを定義するときは上書きするのではなく、拡張した感じで、他のStringメソッドに影響がないです。</p>

<p><em>gist id=1205255 file=solution_2.rb</em>
solution_2.rbはただ<strong>class_eval</strong>の理論を試したかっただけです。<strong>class_eval</strong>はスコープ内の<strong>self</strong>と<strong>current class</strong>をreceiverのStringクラスに変更するんです。だからclass_evalのブロック内に定義したメソッドはStringのinstance methodになります。</p>

<p><em>gist id=1205255 file=solution_mistake.rb</em>
solution_mistake.rbはStringのクラスメソッド(Singleton methods)を定義したもので、instance methodではないです。</p>

<p>最近「Metaprogramming Ruby」という本を読んでます。よくわからなかったこととか、曖昧だっだことがすっきりした感じです。お勧めです！</p>
]]></content>
  </entry>
  
</feed>
